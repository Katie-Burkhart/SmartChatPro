{"filename": "01_assignment_Intro_to_Python_and_Variables.pdf", "text": "Assignment: Basic Variable Operations\nObjective: Practice creating and modifying Python variables.\nTasks: 1. Create variables for 'name', 'age', and 'gpa'. Print them using f-strings. 2. Update 'gpa' to a new value and\nprint again. 3. Add two numeric variables and display the result. 4. Create a constant for PI = 3.14159 and print\nthe area of a circle (r=5).\nSave your work as 'assignment1.py'. Ensure variable names are descriptive and code is properly commented."}
{"filename": "01_concept_Intro_to_Python_and_Variables.pdf", "text": "Concept: Introduction to Python and Variables\nPython is an interpreted, high-level programming language designed to be simple and readable. It uses indentation\ninstead of braces and supports multiple paradigms such as procedural, object-oriented, and functional\nprogramming.\nVariables in Python are used to store data values. Unlike many languages, Python does not require explicit type\ndeclarations. A variable is created when a value is assigned to a name.\nVariable naming rules: Names must begin with a letter or underscore, cannot contain spaces, and are case\nsensitive. For example, 'studentName' and 'StudentName' are two different variables.\nPython supports dynamic typing, meaning the same variable can hold different types of data during program\nexecution.\nUse comments (#) to describe your code. Always use meaningful variable names for clarity.\nBest practices include keeping code readable, using snake_case for variable names, and limiting the use of global\nvariables.\nx = 10\nname = 'Aisha'\ngpa = 3.8\nprint(f'My name is {name}, GPA is {gpa}')\nprice = 25.5\nprice = price + 4.5\nprint('Updated price:', price)"}
{"filename": "02_assignment_Data_Types_and_Type_Casting.pdf", "text": "Assignment: Numbers and Strings Practice\nObjective: Reinforce understanding of Python data types and conversions.\nTasks: 1. Create variables for an integer, float, and string, and print their types. 2. Convert the string '100' to an\ninteger and add it to another number. 3. Write code to accept a user's name and age (as strings) and print a\ngreeting converting age to an integer.\nSave as 'assignment2.py'. Include comments explaining conversions."}
{"filename": "02_concept_Data_Types_and_Type_Casting.pdf", "text": "Concept: Data Types and Type Casting\nPython has several built-in data types such as integers (int), floating-point numbers (float), strings (str), and\nbooleans (bool). Each data type represents a specific kind of data that determines the operations you can perform\non it.\nType casting is converting one data type to another, such as changing a string to an integer. Use int(), float(), or\nstr() for conversion.\nBe cautious when casting—casting an invalid string to an integer will cause an error. Use exception handling\nwhen appropriate.\nExample: converting user input (which is a string) into a number for calculation.\nPython also supports complex numbers and the None type for representing null values.\nx = 5\ny = 2.5\nz = '10'\nprint(type(x), type(y), type(z))\nz = int(z)\nprint(x + z)\ntemp = 98.6\nprint('Temperature:', str(temp) + '°F')"}
{"filename": "03_assignment_Conditional_Statements.pdf", "text": "Assignment: If-Else Scenarios\nObjective: Practice using conditional statements to control program logic.\nTasks: 1. Write a program to determine if a number is positive, negative, or zero. 2. Create a grade calculator that\nprints A, B, C, D, or F based on numeric score. 3. Check if a user-entered year is a leap year. 4. Use nested ifs to\nprint if a number is even and greater than 10.\nSave as 'assignment3.py'. Ensure proper indentation and meaningful print messages."}
{"filename": "03_concept_Conditional_Statements.pdf", "text": "Concept: Conditional Statements\nConditional statements allow your program to make decisions. Python uses if, elif, and else blocks to control the\nflow of execution based on boolean expressions.\nIndentation is critical. Each block under an if or else must be indented equally.\nComparison operators include ==, !=, >, <, >=, <=, and logical operators are and, or, not.\nNested conditions and combined expressions can handle more complex logic.\nAlways test your code for multiple conditions to ensure all branches behave as expected.\nx = 10\ny = 20\nif x < y:\n print('x is less than y')\nelse:\n print('x is greater or equal to y')\nscore = 85\nif score >= 90:\n print('A')\nelif score >= 80:\n print('B')\nelse:\n print('C or below')"}
{"filename": "04_assignment_Loops.pdf", "text": "Assignment: Iteration Exercises\nObjective: Develop familiarity with Python loops.\nTasks: 1. Use a for loop to print numbers 1–10. 2. Create a while loop that sums numbers until total > 100. 3. Print\nall even numbers between 1 and 50. 4. Use nested loops to print a multiplication table (1–5).\nSave as 'assignment4.py'. Use comments to explain your logic."}
{"filename": "04_concept_Loops.pdf", "text": "Concept: Loops\nLoops allow repeated execution of a block of code. Python provides 'for' and 'while' loops.\nA for loop iterates over a sequence like a list, tuple, or string. A while loop continues as long as a condition is\ntrue.\nUse 'break' to exit a loop early, and 'continue' to skip an iteration.\nAvoid infinite loops by ensuring conditions eventually become false.\nLooping is key for tasks like processing data, reading files, and repeated calculations.\nfor i in range(5):\n print('Iteration', i)\ncount = 0\nwhile count < 3:\n print('Count:', count)\n count += 1"}
{"filename": "05_assignment_Functions.pdf", "text": "Assignment: Function Implementation Practice\nObjective: Build and call functions to perform various tasks.\nTasks: 1. Write a function that takes a name and prints a greeting. 2. Create a function that adds two numbers and\nreturns the result. 3. Define a function with a default parameter. 4. Write a function that returns the factorial of a\nnumber using a loop.\nSave as 'assignment5.py'. Use docstrings and descriptive function names."}
{"filename": "05_concept_Functions.pdf", "text": "Concept: Functions\nFunctions help organize code into reusable blocks. They are defined using the def keyword followed by a function\nname and parentheses.\nArguments are values passed into functions. Use return to send a value back. Functions make code modular,\neasier to debug, and reusable.\nDefault arguments provide fallback values. You can also use keyword arguments when calling functions.\nDocstrings (triple quotes) describe what a function does—use them for clarity.\nPython also supports lambda functions (anonymous, short functions).\ndef greet(name):\n return f'Hello, {name}!'\nprint(greet('Alice'))\ndef add(a, b=5):\n return a + b\nresult = add(3)\nprint('Result:', result)\nsquare = lambda x: x*x\nprint(square(4))"}
{"filename": "06_assignment_Lists.pdf", "text": "Assignment: List Operations Practice\nObjective: Strengthen understanding of Python lists and common manipulations.\nTasks: 1. Create a list of 5 student names and print the second and last names. 2. Add a new name, remove one,\nand print the updated list. 3. Create a list of 10 numbers and print only even numbers using a loop. 4. Use list\ncomprehension to generate squares of numbers 1–10.\nSave as 'assignment6.py'. Add comments explaining each operation."}
{"filename": "06_concept_Lists.pdf", "text": "Concept: Lists\nLists are ordered collections of items, allowing storage of multiple values in a single variable. They are mutable,\nmeaning elements can be changed after creation.\nLists can contain mixed data types and even other lists. Elements are indexed starting at 0.\nCommon operations include appending, removing, sorting, and slicing. Lists are one of Python’s most versatile\ndata structures.\nUse list comprehensions for concise creation and transformation of lists.\nfruits = ['apple', 'banana', 'cherry']\nprint(fruits[0])\nfruits.append('orange')\nfruits.remove('banana')\nprint(fruits)\nsquares = [x**2 for x in range(5)]\nprint(squares)"}
{"filename": "07_assignment_Tuples.pdf", "text": "Assignment: Tuple Exercises\nObjective: Understand tuple creation, unpacking, and immutability.\nTasks: 1. Create a tuple to store a student’s name, age, and GPA. 2. Unpack the tuple and print each value. 3.\nTry modifying one element and observe the error. 4. Combine two tuples and print the result.\nSave as 'assignment7.py'. Explain tuple immutability in comments."}
{"filename": "07_concept_Tuples.pdf", "text": "Concept: Tuples\nTuples are similar to lists but immutable — their elements cannot be modified after creation. They are useful for\nstoring fixed data sets.\nTuples use parentheses instead of square brackets. Because they are immutable, they are faster and can be used as\ndictionary keys.\nYou can unpack tuple values into variables and iterate through them easily.\ncoordinates = (10, 20)\nprint('X:', coordinates[0], 'Y:', coordinates[1])\nx, y = coordinates\nprint('x + y =', x + y)"}
{"filename": "08_assignment_Dictionaries.pdf", "text": "Assignment: Dictionary Operations\nObjective: Learn to use dictionaries for structured data.\nTasks: 1. Create a dictionary with keys: name, age, and city. 2. Add a new key 'GPA' and update an existing\nvalue. 3. Loop through and print all key-value pairs. 4. Write a program to store and retrieve phone numbers using\nnames as keys.\nSave as 'assignment8.py'. Comment on dictionary advantages over lists."}
{"filename": "08_concept_Dictionaries.pdf", "text": "Concept: Dictionaries\nDictionaries store key-value pairs, enabling fast data lookup. They are unordered (until Python 3.7+) and mutable.\nCommon operations include adding, updating, deleting, and retrieving values using keys.\nUse the get() method to safely access values, avoiding KeyError exceptions.\nstudent = {'name': 'Liam', 'age': 21, 'major': 'AI'}\nprint(student['name'])\nstudent['age'] = 22\nstudent['GPA'] = 3.9\nprint(student)\nfor key, value in student.items():\n print(key, '->', value)"}
{"filename": "09_assignment_Sets.pdf", "text": "Assignment: Set Operations\nObjective: Practice set creation and operations.\nTasks: 1. Create a set with some duplicate numbers and print it. 2. Find intersection and union between two sets.\n3. Write code to find unique words from a given sentence. 4. Check membership for a given element.\nSave as 'assignment9.py'. Use comments to explain each set operation."}
{"filename": "09_concept_Sets.pdf", "text": "Concept: Sets\nSets are unordered collections of unique items. They automatically remove duplicates and support mathematical\noperations such as union, intersection, and difference.\nSets are mutable but do not support indexing or slicing since they are unordered.\nThey are ideal for eliminating duplicates and checking membership efficiently.\nnums = {1, 2, 3, 3, 4}\nprint(nums)\nsetA = {1, 2, 3}\nsetB = {3, 4, 5}\nprint('Union:', setA | setB)\nprint('Intersection:', setA & setB)"}
{"filename": "10_assignment_File_Handling.pdf", "text": "Assignment: File Read/Write Tasks\nObjective: Learn reading from and writing to files.\nTasks: 1. Write a Python program to write 5 student names to a text file. 2. Read the file content and display it. 3.\nAppend two more names and print the final file content. 4. Handle exceptions if the file is not found.\nSave as 'assignment10.py'. Test with both 'w' and 'a' modes."}
{"filename": "10_concept_File_Handling.pdf", "text": "Concept: File Handling\nFile handling in Python allows reading and writing data to external files. It is essential for persistent data storage.\nUse open() function with modes: 'r' (read), 'w' (write), 'a' (append), and 'r+' (read/write). Always close files after\nuse to free resources.\nThe with statement is recommended for automatic file closure.\nReading can be done line by line or all at once, and writing replaces content unless you use append mode.\nwith open('example.txt', 'w') as f:\n f.write('Hello, world!')\nwith open('example.txt', 'r') as f:\n content = f.read()\n print(content)"}
{"filename": "11_assignment_Exception_Handling.pdf", "text": "Assignment: Try-Except Practice\nObjective: Handle runtime errors effectively.\nTasks: 1. Write code that divides two user-input numbers. Handle division by zero. 2. Use try-except to catch\ninvalid input types. 3. Implement a program that reads a file and catches FileNotFoundError. 4. Use finally to\ndisplay 'Program Ended' after execution.\nSave as 'assignment11.py'. Include comments explaining each error type."}
{"filename": "11_concept_Exception_Handling.pdf", "text": "Concept: Exception Handling\nException handling in Python allows developers to manage errors gracefully and prevent program crashes. Errors\nlike division by zero or accessing undefined variables can be intercepted using try-except blocks.\nThe basic syntax is: try: # code that may raise error except ExceptionType: # handle the error\nYou can catch specific exceptions such as ValueError, ZeroDivisionError, or FileNotFoundError. Always avoid\nbroad exception handling unless necessary.\nThe finally block executes code regardless of whether an exception occurred, making it useful for closing files or\nfreeing resources.\ntry:\n x = int(input('Enter number: '))\n print(10/x)\nexcept ZeroDivisionError:\n print('Cannot divide by zero')\nexcept ValueError:\n print('Please enter a valid number')\nfinally:\n print('Execution completed')"}
{"filename": "12_assignment_OOP.pdf", "text": "Assignment: OOP Mini Project\nObjective: Implement and understand classes, objects, and inheritance.\nTasks: 1. Create a class 'Car' with attributes make, model, and year. 2. Add a method display_info() to print car\ndetails. 3. Derive a subclass 'ElectricCar' that adds a battery_size attribute. 4. Override display_info() to include\nbattery info. 5. Create objects of both classes and display their details.\nSave as 'assignment12.py'. Comment on inheritance and method overriding."}
{"filename": "12_concept_OOP.pdf", "text": "Concept: Object-Oriented Programming (OOP)\nOOP is a programming paradigm that organizes code into classes and objects. Classes define the blueprint, while\nobjects are instances of those classes.\nCore principles: encapsulation, inheritance, and polymorphism. Encapsulation hides internal details; inheritance\nallows class reuse; polymorphism enables methods with the same name to behave differently.\nClasses use the def __init__() constructor for initializing object attributes.\nUsing OOP makes code modular, maintainable, and reusable.\nclass Student:\n def __init__(self, name, age):\n self.name = name\n self.age = age\n def display(self):\n print(f'Name: {self.name}, Age: {self.age}')\ns1 = Student('Ava', 20)\ns1.display()\nclass Graduate(Student):\n def __init__(self, name, age, degree):\n super().__init__(name, age)\n self.degree = degree\n def show(self):\n print(f'{self.name} graduated in {self.degree}')"}
{"filename": "13_assignment_Modules_and_Packages.pdf", "text": "Assignment: Module Practice\nObjective: Understand the use of Python modules and packages.\nTasks: 1. Create a custom module 'greetings.py' with a function hello(name). 2. Import and use it from another\nfile. 3. Use built-in 'math' and 'random' modules in your program. 4. Explore os module to print the current\nworking directory.\nSave as 'assignment13.py'. Ensure your module runs without errors."}
{"filename": "13_concept_Modules_and_Packages.pdf", "text": "Concept: Modules and Packages\nModules are Python files containing reusable code such as functions or classes. They help organize programs into\nseparate files for maintainability.\nImporting a module allows access to its contents using the import keyword. Use 'from module import function' to\nimport specific items.\nPackages are directories containing multiple modules and an __init__.py file. They enable hierarchical\norganization of large projects.\nBuilt-in modules like math, os, and random are widely used in daily programming.\nimport math\nprint('Square root of 16:', math.sqrt(16))\nfrom random import randint\nprint('Random number:', randint(1, 10))"}
{"filename": "14_assignment_Numpy_Basics.pdf", "text": "Assignment: Numpy Arrays Practice\nObjective: Practice creating and manipulating numpy arrays.\nTasks: 1. Create a 1D numpy array with numbers 1–10 and print its mean and standard deviation. 2. Create a 2D\narray (3x3) and print the transpose. 3. Perform element-wise multiplication between two arrays. 4. Slice the array\nto print only even elements.\nSave as 'assignment14.py'. Include numpy import at the top."}
{"filename": "14_concept_Numpy_Basics.pdf", "text": "Concept: Numpy Basics\nNumpy (Numerical Python) is a library for fast mathematical computation using arrays. It supports\nmulti-dimensional arrays, broadcasting, and numerous mathematical functions.\nUnlike Python lists, numpy arrays are homogeneous and more efficient in memory and performance.\nCommon operations include array creation, reshaping, slicing, and element-wise operations.\nimport numpy as np\narr = np.array([1, 2, 3, 4])\nprint('Array:', arr)\nprint('Mean:', np.mean(arr))\nmatrix = np.array([[1, 2], [3, 4]])\nprint('Matrix sum:', np.sum(matrix))"}
{"filename": "15_assignment_Pandas_Basics.pdf", "text": "Assignment: DataFrame Operations\nObjective: Practice creating and analyzing Pandas DataFrames.\nTasks: 1. Create a DataFrame with columns Name, Age, and GPA. 2. Add a new column 'Status' based on GPA\n(>3.5 = Pass). 3. Filter students aged above 21. 4. Save the DataFrame to a CSV file named 'students.csv'.\nSave as 'assignment15.py'. Include comments describing each DataFrame operation."}
{"filename": "15_concept_Pandas_Basics.pdf", "text": "Concept: Pandas Basics\nPandas is a library for data analysis and manipulation. It provides two key structures: Series (1D) and DataFrame\n(2D).\nDataFrames are like spreadsheets; they have labeled rows and columns. Pandas integrates seamlessly with Numpy\nfor numerical operations.\nCommon operations: reading CSV files, indexing, filtering, grouping, and summarizing data.\nUse df.head() to preview, df.describe() for statistics, and df.info() for metadata.\nimport pandas as pd\ndata = {'Name': ['Liam', 'Emma'], 'Age': [21, 22]}\ndf = pd.DataFrame(data)\nprint(df)\nprint('Average age:', df['Age'].mean())"}
